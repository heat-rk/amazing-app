# **Amazing App :)**
## Скриншоты приложения
* Главное меню приложения;
<img src="/readme_assets/menu.png" alt="drawing" width="50%"/>

* Невероятное зеркало;
<img src="/readme_assets/mirror.png" alt="drawing" width="50%"/>

* Невероятные факты;
<img src="/readme_assets/facts.png" alt="drawing" width="50%"/>

* Невероятные оскорбления :D;
<img src="/readme_assets/insults.png" alt="drawing" width="50%"/>

* Хейт-топ (что-то по типу журнала, в который можно вносить "плохих" людей и "плохие" предметы);
<img src="/readme_assets/hatetop.png" alt="drawing" width="50%"/>

* Редактор добавления элемента в хейт-топ.
<img src="/readme_assets/hatetop_editor.png" alt="drawing" width="50%"/>

## Архитектура приложения
### Многомодульность
Приложение разбито на следующие модули:
* **Core** - модули, которые содержат в себе фундамент приложения (дизайн, работу с данными, навигация и прочее);
* **Common** - модули, которые содержат в себе какие-то общие компоненты для модулей, например различные утилиты, которые не являются функциональной частью приложения, но позволяют упростить разработку;
* **Feature** - модули, отвечающие за определённые фичи приложения, в моём случае каждый раздел в главном меню приложения вынесен в отдельный модуль;
* **BuildSrc** - модуль, хранящий в себе конфигурацию сборки приложения с описанием всех необходимых зависимостей, плагинов и их версий.

### Архитектура модулей
Все модули по возможности и необходимости придерживаются чистой архитектуры. Схема использованной в этом приложении чистой архитектуры представлена на рисунке ниже:

![image](/readme_assets/arch.png)

Также сами фичи зачастую делятся (по крайней мере такой подход является обязательным в Feature-модулях) на интерфейс и реализацию. Если какая-то фича "A" нуждается в какой-то другой фиче "B", то модуль-реализация фичи "A" может подключить к себе только модуль-интерфейс фичи "B". Это сделано для того, чтобы избежать циклических зависимостей и не завязываться на какую-то определенную реализацию фичи, чтобы её в любой момент можно было без трудностей подменить.

### Архитектура слоя представления
Для слоя представления используется достаточно простая реализация MVI-подхода в виде библиотеки [Orbit](https://github.com/orbit-mvi/orbit-mvi). Используются её стандартные инструменты, поэтому более подробная информация предоставлена в документации к библиотеке.

### Навигация
Идея навигации в этом приложении в том, что Feature-модули ничего не должны знать о реализации навигации: ни о библиотеке, ни о UI фреймворке. Чтобы этого достичь, нужно пройтись по следующим шагам:
1. Каждый Feature-модуль, который предоставляет какие-либо навигируемые экраны, должен реализовывать интерфейс **Route**, лежащий в модуле **:core:navigation:api**, в своём модуле-интерфейсе;
2. Реализовать обработку **Route** в конечном приложении (в нашем случае модуль **:app**):
   1. Создать фреймворк-реализацию (в нашем случае **Compose**) роута и добавить этот роут в граф **presentation.navigation.Graph.kt**;
   2. Добавить маппинг из **Route** в фреймфорк-реализацию на **Compose** в файле **presentation.navigation.ComposeRouteHandler.kt**.
3. В модуле реализации фичи с помощью внедрения зависимостей получить доступ к реализации интерфейса **Router**, с помощью которого можно вызывать навигацию даже внутри **ViewModel-и**.

### Внедрение зависимостей
В качестве инструмента для внедрения зависимостей была выбрана библиотека [Scout](https://github.com/yandex/scout). О всех нюансах этого инструмента можно посмотреть в официальной документации или в официальной [статье](https://habr.com/ru/companies/yandex/articles/764920/), где объясняется, почему, зачем и как была создана эта библиотека.